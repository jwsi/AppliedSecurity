-------------------------------------------------------------------------------

1. Instructions

- replace any [...] with free text,
  and
- replace the [?] with an X if you have completed that stage,
- replace the [?] with an * if you have attempted that stage, but you know
  it doesn't work completely; document why you think it doesn't work, plus
  what you would do to fix the problem, at the end of the marksheet.

-------------------------------------------------------------------------------

2. Information

So that we can calibrate and improve the assignment in the future, give us
a rough idea how long (in hours) you spent on it *in total*:

effort : stage 1 -> [22] hours
effort : stage 2 -> [25] hours
effort : stage 3 -> [33] hours
effort : stage 4 -> [40] hours

-------------------------------------------------------------------------------

3. Citation

Clearly it might have an influence on your mark, but the use of third-party
resources *is* allowed *if* correctly cited (unless explicitly prohibited
by the assignment description of course).  Let us know what third-party
source code or resources you used (if any) so it's clear what's your work
and what isn't:

[
    stage1:
        RSA-OAEP CCA attack:
            http://archiv.infsec.ethz.ch/education/fs08/secsem/Manger01.pdf
        OAEP Decoding:
            https://tools.ietf.org/html/rfc3447#section-7.1.1
        MGF1 Algorithm:
            https://tools.ietf.org/html/rfc2437#section-10.2.1
    stage2:
        RSA Timing Attack:
            http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=76B2CB4D4E65E99EE6E7CF46B65000A8?doi=10.1.1.12.3070&rep=rep1&type=pdf
]

-------------------------------------------------------------------------------

4. Marking

The following gives a stage-by-stage description of the assignment marking
scheme.  Note this acts as an indicative guideline only, including weights
for each more obvious aspect (e.g., functional correctness); other aspects
outside this list can warrant an increase/decrease in marks, with examples
including hard to quantify features such as the efficiency, robustness,
generality, realism, or style of a solution.

[X] Stage 1 : an attack based on error messages
              - correct challenge material                           ( 40%)
              - solution quality wrt. efficiency, robustness etc.    ( 30%)
              - analysis questions                                   ( 30%)

              challenge material (i.e., plaintext  m^{*}) : [72ACCF08DA8AB6FD918C3D61247C7EC4C150DCC0A7D8] (IN HEX)

[X] Stage 2 : an attack based on execution time
              - correct challenge material                           ( 40%)
              - solution quality wrt. efficiency, robustness etc.    ( 30%)
              - analysis questions                                   ( 30%)

              challenge material (i.e., exponent   d^{*}) : [25802675D0B01797] (IN HEX)

[X] Stage 3 : an attack based on an injected fault
              - correct challenge material                           ( 40%)
              - solution quality wrt. efficiency, robustness etc.    ( 30%)
              - analysis questions                                   ( 30%)

              challenge material (i.e., cipher key k^{*}) : [1F522029440BF387878D7C9F14EF9EFF] (IN HEX)

[X] Stage 4 : an attack based on power consumption
              - correct challenge material                           ( 40%)
              - solution quality wrt. efficiency, robustness etc.    ( 30%)
              - analysis questions                                   ( 30%)

              challenge material (i.e., cipher key k^{*}) : [FB27E1C3706EE04DF34DE1D03F7D14EA0C98B5659A181E312AAE95802913E61D] (IN HEX)

                                                                     ------
                                                                     (400%)

-------------------------------------------------------------------------------

5. Documentation

Any other documentation, notes or comments that you think are important or
might be easy to overlook (e.g., a subtle issue or technique in associated
source code) should go here:

[
    stage1:
        This attack directly follows Manger's paper on a CCA attack for
        RSA-OAEP. For my particular oracle, the hex XOR function had to
        be engineered slightly more carefully such that the output is padded
        to the length of the biggest input parameter, otherwise when passing
        the resulting output to a hex decoder it would error due to an odd
        length string.
        In addition to the above, I made the decision to implement my own
        floored and ceiling division functions. By doing this it allowed me
        to implement the entire attack in Python Integer/Long types. If I had
        used math.ceil and math.floor from the Python math library I would have
        had to work in floats or the multi precision Decimal type. This would
        have likely resulted in issues with the large numbers that I was
        dealing with as a float type wouldn't have been able to hold numbers of
        these sizes. Thus, casting to a multi precision Decimal wouldn't have
        helped as some data would have been lost due to the limited size of
        floats which is the type returned by math.floor and math.ceil.
        As a footnote the RSA-OAEP decoding function and the MGF1 algorithm
        were implemented by using the RFC documents cited above.
    stage2:
        To improve the efficiency of this attack, the oracle is first queried
        at the beginning. 4000 messages and their associated timing data are
        gathered to form the base sample.
        The timing data is then compared and sorted into groups (see paper
        referenced above...) and bit predictions of the key is made by
        analysing these groups. If a decision cannot be made, then a restart
        is triggered and 1000 more samples are added to the message set. If
        the sample set reaches 10000 messages, a hard reset is triggered whereby
        the entire message space is eradicated. Subsequently a new initial
        message space is grafted and the process restarts again. By taking this
        approach it ensures that if large amounts of noise have entered the
        sample, it has the chance to restart completely which is often more
        efficient than adding more and more good samples to an already large
        abnormal set.
    stage3:
    stage4:
]

-------------------------------------------------------------------------------
