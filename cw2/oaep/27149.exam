Q.1 Consider the parameters N = 3551, e = 5, d = 1373, and c = 888, all
    represented in decimal.  Use them to explain, in your own words, the
    principle of this attack (e.g., how and why it works).

    Denote B as: B = 2^8(k-1) where k is the size of the RSA modulus N in
    bytes. k = ceil(log_256(N)) = 2. Therefore B = 2^8 = 256.
    B can intuitively make sense, we know any valid message must start with
    00 in HEX. This 00 corresponds to 1 byte less of information than N.
    Therefore, the maximum size of a message must be no greater than B (the
    size of N in bits - 256).
    If an oracle reveals this boundary in the form of an error message during
    decryption this gives an adversary the ability to manipulate ciphertexts
    to work out a lower and upper boundary to which decryption succeeds and
    then fails. Subsequently, an adversary can then reduce this boundary
    further and further until the plaintext message is deduced.

    STEP 1:
        This step finds the first cutoff point for f*m (mod N) to be greater
        than B. As ((f^e) * c)^d ≡ f*m (mod N)
        f1 is the first power of two such that (f1^5) * 888 sent to the oracle
        returns >=B during the decryption phase.
        (2^5 * 888)^1373 (mod 3551) ≡ 246
        The result is less than B so increase f1
        (4^5 * 888)^1373 (mod 3551) ≡ 492
        We want f1^e * c ∈ [B, 2B] equivalently, f1 * m ∈ [B, 2B]
        Therefore, f1 = 4
        consequently => (f1/2) * m ∈ [B/2, B]

    STEP 2:
        We use the result from step 1 here.
        We want to achieve a value of f2 st. f2 * m ∈ [N, N+B]
        We start with f2 st. f2*m is just less than N+B, then we keep
        increasing f2 at each stage until the oracle returns <B (a
        modular wrap around occurs).
        Start at f2 = floor((N+B)/B) * f1/2 = 28 and send to the oracle
        (28^5 * 888)^1373 (mod 3551) = 3444
        The result is clearly bigger than B so increase f2
        f2 = 28 + 2 = 30
        (30^5 * 888)^1373 (mod 3551) = 139
        We see that this has wrapped around and is now less than B.
        Therefore f2 = 30
        From this we can conclude f2 * m ∈ [N, N+B]

    STEP 3:
        In this step we try multiples of f3 in a range of 2B. Each successive
        oracle response will halve the range and when the range becomes
        singular we know this equals our plaintext message.
        m_min = ceil(N/f2) = 119
        m_max = floor((N+B)/f2) = 126
        Furthermore, f2 * (m_max - m_min) ≈ B
        check... 29 * (126-119) = 210 ≈ B

        f_tmp = floor((2*B)/(m_max-m_min)) = 73
        i = floor((f_tmp * m_min)/N) = 2
        f3 = ceil((i*N)/m_min) = 60
        Try f3 with the oracle...
        (f3^e * c)^d ≡ (60^5 * 888)^1373 ≡ 278 (mod 3551)
        This is greater than B so update m_min....
        m_min = ceil((i*N+B)/f3) = 123

        f_tmp = floor((2*B)/(m_max-m_min)) = 170
        i = floor((f_tmp * m_min)/N) = 5
        f3 = ceil((i*N)/m_min) = 145
        Try f3 with the oracle...
        (f3^e * c)^d ≡ (145^5 * 888)^1373 ≡ 80 (mod 3551)
        This is less than B so update m_max....
        m_max = floor((i*N+B)/f3) = 124

        f_tmp = floor((2*B)/(m_max-m_min)) = 512
        i = floor((f_tmp * m_min)/N) = 17
        f3 = ceil((i*N)/m_min) = 491
        Try f3 with the oracle...
        (f3^e * c)^d ≡ (491^5 * 888)^1373 ≡ 26 (mod 3551)
        This is less than B so update m_max....
        m_max = floor((i*N+B)/f3) = 123

        Now m_min == m_max therefore, the decrypted message must be 123.
        Verification: 888^1373 mod 3551 = 123


Q.2 To prevent the attack, the vendor suggests altering the software: the
    idea is that no matter what error occurs, the same error code will be
    produced.  Explain whether (and why, or why not) this change alone is
    sufficient.

    This change alone is sufficient because all the steps in the attack
    algorithm from Manger's paper rely on knowing whether the resulting
    plaintext derived from the ciphertext sent to the oracle is larger or
    smaller than B. B is the value of 2^8(k-1) where k is the size of the
    RSA modulus N, in octets (bytes). If the oracle didn't reveal this
    information to the adversary, then this attack wouldn't be possible as no
    information about the length of the plaintext relative to B would be
    shared. So in short, masking all the error codes to be the same
    (i.e. Decryption Error) would mitigate against this attack.


Q.4 This attack is based on the fact that decrypting a ciphertext of the
    form c = (f^e)*c' mod N produces a plaintext of the form f*m' mod N.
    Show why this fact is true.

    c = (f^e) * c' (mod N)
    To decrypt we raise c to the power of d (the private key)...
    c^d ≡ ((f^e) * c')^d (mod N)
    c^d ≡ ((f^e)^d) * (c'^d) (mod N)
    We know e^-1 ≡ d (mod phi(N)) => e*d ≡ 1 (mod phi(N)) =>
    e*d = k*phi(N) + 1 for some k ∈ ℕ. Subsequently, via Euler's
    Theorem or Lagrange's theorem; a^phi(N) ≡ 1 (mod N) if gcd(a, N) = 1
    c^d ≡ ((f^e)^d) * ((m'^e)^d) (mod N)
    c^d ≡ (f^k*phi(N)+1) * (m'^k*phi(N)+1) (mod N)
    Via Lagrange or Euler above this yields...
    c^d ≡ (f^1) * (m'^1) (mod N)
    Therefore, c^d ≡ f*m' (mod N)


Q.8 Imagine you are a security consultant, employed by the device vendor.
    The vendor has heard that exponent and message blinding can be used to
    prevent some side-channel attacks on RSA.  Explain whether these
    techniques would prevent this attack, and why.

    These techniques would not prevent this attack. They are designed to
    mitigate a completely different side channel attack. In this case the
    oracle is directly giving you information based on the decryption process
    so no matter if you use exponent or message blinding internally; it will
    still give you this information! To sum up, these kind of countermeasures
    are designed to change the decryption process and thus prevent adversaries
    from gaining information via differential timing, power or similar analysis
    attacks. However, as the oracle reports on the finished decryption process
    and errors at this stage, it makes no difference having these
    countermeasures in place for this attack. Subsequently, these
    countermeasures will not help here, but may be useful for other situations.